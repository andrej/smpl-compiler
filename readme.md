# Another Smpl Compiler

Provides a (somewhat) optimizing compiler for the Smpl programming language
for the UC Irvine CS 241 Advanced Compiler Design class.

For help running the compiler, see

    ./main.py --help

## Structure

The path from input file to compiled machine code goes as follows:

1. input file
2. lexer (provides stream of tokens) and parser (creates tree of AST nodes), see `parser.py`
3. AST, see `ast.py`
   1. Interpreter: each AST node has a `run()` method that implements that
      nodes semantics
   2. Compiler: We produce a single static assignment intermediate representation.
      For this, each AST node has a `compile()` method that takes a
      `CompilationContext` and appends (emits) the appropriate instructions to
      this context's instruction stream.
      
      `IfStatement`s and `WhileStatement`s create new basic blocks in the context.
      Note that both of these statements end in one join block; the context is
      updated such that the current basic block is this join block after compilation
      of if and while statements, hence it is safe to keep emitting the following
      instructions after an if/while statement in the _current_ basic block.
      
4. Common subexpression elimination, dead code elimination and constant elimination, 
   see `ssa.py`
   
   **Common subexpression elimination** is performed as statements are compiled:
   The `emit()` method of the compilation context checks whether an equivalent
   dominating instruction exists. If so, a pointer to that instruction is returned
   and no instruction is emitted.

5. DLX machine code or assembly generation, see `backend.py` (abstract base class),
   `dlx.py` and `allocator.py`. The machine code is generated by iterating through
   the SSA IR basic blocks in a depth-first manner; the backend in `dlx.py` calls
   back to its given allocator (`allocator.py`) to map the SSA operands to actual
   machine registers and memory locations (for spills).